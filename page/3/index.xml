<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gongluck&#39;s blog</title>
    <link>https://gongluck.github.io/</link>
    <description>Recent content on gongluck&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 21 Sep 2024 21:05:21 +0800</lastBuildDate>
    
        <atom:link href="https://gongluck.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>CGO入门</title>
        <link>https://gongluck.github.io/go/cgo_quick_start/</link>
        <pubDate>Thu, 09 Apr 2020 19:31:36 +0800</pubDate>
        
        <guid>https://gongluck.github.io/go/cgo_quick_start/</guid>
        <description>gongluck&#39;s blog https://gongluck.github.io/go/cgo_quick_start/ -&lt;p&gt;C/C++加上GO代表什么？&lt;/p&gt;
&lt;p&gt;代表着既可以使用GO快速的开发项目,同时可以接纳C/C++的庞大历史遗产和极高性能！而且在GO中使用C/C++十分简单！&lt;/p&gt;
&lt;h3 id=&#34;代码仓库&#34;&gt;代码仓库&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/gongluck/CGO-DEMO.git&#34;&gt;https://github.com/gongluck/CGO-DEMO.git&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;准备&#34;&gt;准备&lt;/h3&gt;
&lt;p&gt;使用CGO,需要先安装gcc或者mingw。&lt;/p&gt;
&lt;h3 id=&#34;启用cgo特性&#34;&gt;启用CGO特性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;C&amp;quot;

func main() {
    println(&amp;quot;hello, cgo&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就是这么简单,一句 &lt;em&gt;&lt;strong&gt;import &amp;ldquo;C&amp;rdquo;&lt;/strong&gt;&lt;/em&gt; 就是告诉 &lt;em&gt;&lt;strong&gt;go build&lt;/strong&gt;&lt;/em&gt; 命令在编译和链接阶段启动gcc编译器。&lt;/p&gt;
&lt;h3 id=&#34;使用c标准库的函数&#34;&gt;使用C标准库的函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main

//#include &amp;lt;stdio.h&amp;gt;
import &amp;quot;C&amp;quot;

func main() {
    C.puts(C.CString(&amp;quot;hello, cgo&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;import &amp;ldquo;C&amp;rdquo;&lt;/strong&gt;&lt;/em&gt; 上面紧接着的注释就是C代码,上面就是将标准库的头文件包含进我们的代码中。在GO中使用C的代码都是在伪包&amp;quot;C&amp;quot;中,所以使用C标准库中的 &lt;em&gt;&lt;strong&gt;puts&lt;/strong&gt;&lt;/em&gt; 函数就是 &lt;em&gt;&lt;strong&gt;C.puts(&amp;hellip;)&lt;/strong&gt;&lt;/em&gt; 。由于C和GO中的字符(串)类型不是等价的,使用 &lt;em&gt;&lt;strong&gt;C.CString(&amp;hellip;)&lt;/strong&gt;&lt;/em&gt; 将GO中的 &lt;em&gt;&lt;strong&gt;string&lt;/strong&gt;&lt;/em&gt; 转换成C的 &lt;em&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;/em&gt;* 。&lt;/p&gt;
&lt;h3 id=&#34;使用自定义c函数&#34;&gt;使用自定义C函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main

/*
#include &amp;lt;stdio.h&amp;gt;

static void SayHello(const char* s)
{
    puts(s);
}
*/
import &amp;quot;C&amp;quot;

func main() {
    C.SayHello(C.CString(&amp;quot;hello, cgo\n&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和前面使用C标准库的函数的例子差不多,只是将自定义函数的定义放到 &lt;em&gt;&lt;strong&gt;import &amp;ldquo;C&amp;rdquo;&lt;/strong&gt;&lt;/em&gt; 上面的注释中,接下来就可以在GO中通过&amp;quot;C&amp;quot;包使用了。另外,也可以将自定义C函数的定义放到C源码文件中,GO代码只在 &lt;em&gt;&lt;strong&gt;import &amp;ldquo;C&amp;rdquo;&lt;/strong&gt;&lt;/em&gt; 上面添加该函数的声明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

//void SayHello(const char* s);
import &amp;quot;C&amp;quot;

func main() {
    C.SayHello(C.CString(&amp;quot;hello, cgo\n&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C源码文件的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void SayHello(const char* s)
{
    puts(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果两个源码文件都放在同一层目录下,可以直接使用 &lt;em&gt;&lt;strong&gt;go build&lt;/strong&gt;&lt;/em&gt; 编译。&lt;/p&gt;
&lt;p&gt;其实,自定义的C函数也可以用C++实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

extern &amp;quot;C&amp;quot; {
    #include &amp;quot;hello.h&amp;quot;
}

void SayHello(const char* s) {
    std::cout &amp;lt;&amp;lt; s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是现在就必须通过一个C头文件给GO声明该函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void SayHello(const char* s);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GO代码改为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

//#include &amp;quot;hello.h&amp;quot;
import &amp;quot;C&amp;quot;

func main() {
    C.SayHello(C.CString(&amp;quot;hello, cgo\n&amp;quot;))
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;函数的声明是C的,但是具体内部实现可以是C++的。而且能和GO结合使用的只能是C。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;go导出c接口&#34;&gt;GO导出C接口&lt;/h3&gt;
&lt;p&gt;前面的例子都是GO调用C源码(接口),下面使用GO导出C接口。
首先在C头文件中声明函数,为了适配GO,注释了 &lt;em&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/em&gt; 修饰。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void SayHelloGo(/*const*/ char* s);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在GO源码中实现该接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;C&amp;quot;

import &amp;quot;fmt&amp;quot;

//export SayHelloGo
func SayHelloGo(s *C.char) {
    fmt.Print(C.GoString(s))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过CGO的 &lt;em&gt;&lt;strong&gt;//export SayHello&lt;/strong&gt;&lt;/em&gt; 指令将Go语言实现的函数导出为C语言函数。接下来就可以使用该实际是GO实现的C接口了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

//#include &amp;lt;hello.h&amp;gt;
import &amp;quot;C&amp;quot;

func main() {
    C.SayHelloGo(C.CString(&amp;quot;hello, cgo Go\n&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;面向c接口的go&#34;&gt;面向C接口的GO&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main

//void SayHello(_GoString_ s);
import &amp;quot;C&amp;quot;

import (
    &amp;quot;fmt&amp;quot;
)

func main() {
    C.SayHello(&amp;quot;hello, cgo go&amp;quot;)
}

//export SayHello
func SayHello(s string) {
    fmt.Print(s)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;从Go1.10开始CGO新增加了一个_GoString_预定义的C语言类型，用来表示Go语言字符串。&lt;/strong&gt;&lt;/em&gt;
上面一个GO源码文件中,发生了这样的调用过程。GO的main函数中,调用了&amp;quot;C&amp;quot;包中的 &lt;em&gt;&lt;strong&gt;SayHello&lt;/strong&gt;&lt;/em&gt; 这个C函数,实际这个 &lt;em&gt;&lt;strong&gt;SayHello&lt;/strong&gt;&lt;/em&gt; C函数是GO实现的,所以转向调用GO中的 &lt;em&gt;&lt;strong&gt;SayHello&lt;/strong&gt;&lt;/em&gt; 。&lt;/p&gt;- https://gongluck.github.io/go/cgo_quick_start/ - </description>
        </item>
    
    
    
        <item>
        <title>任务管理器播放BadApple</title>
        <link>https://gongluck.github.io/cpp/badapple-taskmgr/</link>
        <pubDate>Wed, 08 Apr 2020 18:28:36 +0800</pubDate>
        
        <guid>https://gongluck.github.io/cpp/badapple-taskmgr/</guid>
        <description>gongluck&#39;s blog https://gongluck.github.io/cpp/badapple-taskmgr/ -&lt;p&gt;有屏幕的地方就有BadApple!前面做了在控制台显示BadApple了,这一次把画面渲染到任务管理器上！&lt;/p&gt;
&lt;h3 id=&#34;设计思路&#34;&gt;设计思路&lt;/h3&gt;
&lt;p&gt;和上一篇差不多,只是设置指定窗口为libvlc的渲染窗口。找到指定的窗口比较复杂。&lt;/p&gt;
&lt;h3 id=&#34;效果视频&#34;&gt;效果视频&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1B64y1u7rv&#34;&gt;https://www.bilibili.com/video/BV1B64y1u7rv&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码仓库&#34;&gt;代码仓库&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/gongluck/Character-player/tree/taskmgr&#34;&gt;https://github.com/gongluck/Character-player/tree/taskmgr&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//process.cpp
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;#34;process.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;#34;../errcode.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#1e889b&#34;&gt;#ifdef _WIN32
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;TlHelp32.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;tchar.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;atlconv.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; gprocess
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;gethandle&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;* processname, std::vector&amp;lt;ProcessInfo&amp;gt;&amp;amp; result)
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (processname == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
        {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; G_ERROR_INVALIDPARAM;
        }

&lt;span style=&#34;color:#1e889b&#34;&gt;#ifdef _WIN32
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
        USES_CONVERSION;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; processT = A2T(processname);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (hSnapshot == INVALID_HANDLE_VALUE || processT == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
        {
            std::cerr &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; G_ERROR_INTERNAL;
        }

        result.clear();
        ProcessInfo info = { &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; };
        PROCESSENTRY32 pe = { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(pe) };
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; fOk = FALSE;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (fOk = Process32First(hSnapshot, &amp;amp;pe); fOk; fOk = Process32Next(hSnapshot, &amp;amp;pe))
        {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!_tcscmp(pe.szExeFile, processT))
            {
                info.processid = pe.th32ProcessID;
                info.parentid = pe.th32ParentProcessID;
                result.push_back(info);
            }
        }
        CloseHandle(hSnapshot);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; G_ERROR_SUCCEED;
&lt;span style=&#34;color:#1e889b&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; G_ERROR_SUCCEED;
    }

&lt;span style=&#34;color:#1e889b&#34;&gt;#ifdef _WIN32
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;    BOOL CALLBACK &lt;span style=&#34;color:#008b45&#34;&gt;EnumChildWindowCB&lt;/span&gt;(HWND h, LPARAM l)
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; pinfo = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;WindowInfo*&amp;gt;(l);
        DWORD pid = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        GetWindowThreadProcessId(h, &amp;amp;pid);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (pid == pinfo-&amp;gt;processid)
        {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; pchild = std::make_shared&amp;lt;WindowInfo&amp;gt;();
            pchild-&amp;gt;processid = pid;
            pchild-&amp;gt;window = h;
            pinfo-&amp;gt;childs.push_back(pchild);
            EnumChildWindows(h, EnumChildWindowCB, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;LPARAM&amp;gt;(pchild.get()));
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; TRUE;
    }
    BOOL CALLBACK &lt;span style=&#34;color:#008b45&#34;&gt;EnumWindowCB&lt;/span&gt;(HWND h, LPARAM l)
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; pinfo = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;WindowInfo*&amp;gt;(l);
        DWORD pid = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        GetWindowThreadProcessId(h, &amp;amp;pid);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (pid == pinfo-&amp;gt;processid)
        {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; pchild = std::make_shared&amp;lt;WindowInfo&amp;gt;();
            pchild-&amp;gt;processid = pid;
            pchild-&amp;gt;window = h;
            pinfo-&amp;gt;childs.push_back(pchild);
            EnumChildWindows(h, EnumChildWindowCB, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;LPARAM&amp;gt;(pchild.get()));
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; TRUE;
    }
&lt;span style=&#34;color:#1e889b&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getallwindows&lt;/span&gt;(WindowInfo* info)
    {
&lt;span style=&#34;color:#1e889b&#34;&gt;#ifdef _WIN32
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (EnumWindows(EnumWindowCB, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;LPARAM&amp;gt;(info)) != TRUE)
        {
            std::cerr &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; G_ERROR_INTERNAL;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; G_ERROR_SUCCEED;
&lt;span style=&#34;color:#1e889b&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; G_ERROR_SUCCEED;
    }
} &lt;span style=&#34;color:#228b22&#34;&gt;// namespace gprocess
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//main.cpp
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#1e889b&#34;&gt;#ifdef _WIN32
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;tchar.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#define ssize_t SSIZE_T
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;vlc/vlc.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;#34;../../Code-snippet/cpp/process/process.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#1e889b&#34;&gt;#define CHECKEQUALRET(ret, compare)\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;if(ret == compare)\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;{\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;    std::cerr &amp;lt;&amp;lt; &amp;#34;error ocurred in &amp;#34; &amp;lt;&amp;lt; __FILE__\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;              &amp;lt;&amp;lt; &amp;#34;`s line &amp;#34; &amp;lt;&amp;lt; __LINE__\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;              &amp;lt;&amp;lt; &amp;#34;, error &amp;#34; &amp;lt;&amp;lt; ret;\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;    goto END;\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;}
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#1e889b&#34;&gt;#define CHECKNEQUALRET(ret, compare)\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;if(ret != compare)\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;{\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;    std::cerr &amp;lt;&amp;lt; &amp;#34;error ocurred in &amp;#34; &amp;lt;&amp;lt; __FILE__\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;              &amp;lt;&amp;lt; &amp;#34;`s line &amp;#34; &amp;lt;&amp;lt; __LINE__\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;              &amp;lt;&amp;lt; &amp;#34;, error &amp;#34; &amp;lt;&amp;lt; ret;\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;    goto END;\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;}
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getwindows&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; TCHAR* classname,
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; gprocess::WindowInfo&amp;amp; info,
    std::vector&amp;lt;std::shared_ptr&amp;lt;gprocess::WindowInfo&amp;gt;&amp;gt;&amp;amp; result)
{
    std::vector&amp;lt;std::shared_ptr&amp;lt;gprocess::WindowInfo&amp;gt;&amp;gt; tmp;
    TCHAR classname_[MAX_PATH] = { &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; };
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; info.childs.size(); ++i)
    {
        GetClassName(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;HWND&amp;gt;(info.childs[i]-&amp;gt;window), classname_, _countof(classname_));
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (_tcscmp(classname_, classname) == &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)
        {
            tmp.push_back(info.childs[i]);
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt;&amp;amp; each : tmp)
    {
        result.push_back(each);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getwindows&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; TCHAR* classname,
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; std::vector&amp;lt;std::shared_ptr&amp;lt;gprocess::WindowInfo&amp;gt;&amp;gt;&amp;amp; windows,
    std::vector&amp;lt;std::shared_ptr&amp;lt;gprocess::WindowInfo&amp;gt;&amp;gt;&amp;amp; result)
{
    std::vector&amp;lt;std::shared_ptr&amp;lt;gprocess::WindowInfo&amp;gt;&amp;gt; tmp;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; windows.size(); ++i)
    {
        getwindows(classname, *windows[i], tmp);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt;&amp;amp; each : tmp)
    {
        result.push_back(each);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}

&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;** argv)
{
    libvlc_instance_t* inst_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    libvlc_media_t* media_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    libvlc_media_player_t* player_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    libvlc_media_list_t* list_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    libvlc_media_list_player_t* plist_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    HWND wnd_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;

    std::vector&amp;lt;gprocess::ProcessInfo&amp;gt; result;
    gprocess::WindowInfo windowinfo;
    std::vector&amp;lt;std::shared_ptr&amp;lt;gprocess::WindowInfo&amp;gt;&amp;gt; windows;
    std::vector&amp;lt;std::shared_ptr&amp;lt;gprocess::WindowInfo&amp;gt;&amp;gt; tmpwindows;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; ret = gprocess::gethandle(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Taskmgr.exe&amp;#34;&lt;/span&gt;, result);
    CHECKNEQUALRET(ret, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    windowinfo.processid = result[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;].processid;
    ret = gprocess::getallwindows(&amp;amp;windowinfo);
    CHECKNEQUALRET(ret, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);

    ret = getwindows(TEXT(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;TaskManagerWindow&amp;#34;&lt;/span&gt;), windowinfo, windows);
    CHECKNEQUALRET(ret, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    ret = getwindows(TEXT(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;NativeHWNDHost&amp;#34;&lt;/span&gt;), windows, tmpwindows);
    CHECKNEQUALRET(ret, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    windows.clear();
    windows.swap(tmpwindows);
    ret = getwindows(TEXT(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;DirectUIHWND&amp;#34;&lt;/span&gt;), windows, tmpwindows);
    CHECKNEQUALRET(ret, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    windows.clear();
    windows.swap(tmpwindows);
    ret = getwindows(TEXT(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;CvChartWindow&amp;#34;&lt;/span&gt;), windows, tmpwindows);
    CHECKNEQUALRET(ret, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    CHECKEQUALRET(tmpwindows.size(), &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);

    wnd_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;HWND&amp;gt;(tmpwindows[tmpwindows.size() - &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;]-&amp;gt;window);

    inst_ = libvlc_new(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);
    CHECKEQUALRET(inst_, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);
    media_ = libvlc_media_new_path(inst_, argc &amp;lt;= &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;badapple.mp4&amp;#34;&lt;/span&gt; : argv[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;]);
    CHECKEQUALRET(media_, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);

    &lt;span style=&#34;color:#228b22&#34;&gt;//player_ = libvlc_media_player_new_from_media(media_);
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    player_ = libvlc_media_player_new(inst_);
    CHECKEQUALRET(player_, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);

    libvlc_media_player_set_hwnd(player_, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;*&amp;gt;(wnd_));

    &lt;span style=&#34;color:#228b22&#34;&gt;// play loop
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    list_ = libvlc_media_list_new(inst_);
    plist_ = libvlc_media_list_player_new(inst_);
    libvlc_media_list_add_media(list_, media_);
    libvlc_media_list_player_set_media_list(plist_, list_);
    libvlc_media_list_player_set_media_player(plist_, player_);
    libvlc_media_list_player_set_playback_mode(plist_, libvlc_playback_mode_loop);
    libvlc_media_list_player_play(plist_);

    std::cin.get();

END:
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (player_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_media_player_stop(player_);
        libvlc_media_player_release(player_);
        player_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (media_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_media_release(media_);
        media_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (plist_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_media_list_player_release(plist_);
        plist_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (list_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_media_list_release(list_);
        list_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (inst_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_release(inst_);
        inst_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://gongluck.github.io/cpp/badapple-taskmgr/ - </description>
        </item>
    
    
    
        <item>
        <title>字符动画播放器,不止BadApple!</title>
        <link>https://gongluck.github.io/cpp/badapple-console/</link>
        <pubDate>Tue, 07 Apr 2020 12:42:47 +0800</pubDate>
        
        <guid>https://gongluck.github.io/cpp/badapple-console/</guid>
        <description>gongluck&#39;s blog https://gongluck.github.io/cpp/badapple-console/ -&lt;p&gt;有屏幕的地方就有BadApple!在B站看过好多版本,于是我也用控制台做了一个。网上很多人都是直接显示bmp图片的,但我这个版本是用libvlc实时解码和播放的,音频用libvlc播放,画面就是转换成字符后输出到控制台。除了BadApple这种黑白动画,也能播放彩色视频。具体可以看一下效果视频。&lt;/p&gt;
&lt;h3 id=&#34;设计思路&#34;&gt;设计思路&lt;/h3&gt;
&lt;p&gt;libvlc解码转码出RGBA和播放音频，再将RGBA量化为黑(&#39;*&#39;)白(&#39; &amp;lsquo;)两个颜色并输出到屏幕。&lt;/p&gt;
&lt;h3 id=&#34;效果视频&#34;&gt;效果视频&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1N64y1u7BD&#34;&gt;https://www.bilibili.com/video/BV1N64y1u7BD&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码仓库&#34;&gt;代码仓库&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/gongluck/Character-player/tree/console&#34;&gt;https://github.com/gongluck/Character-player/tree/console&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;thread&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;atomic&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#1e889b&#34;&gt;#ifdef _WIN32
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#define ssize_t SSIZE_T
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;vlc/vlc.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#1e889b&#34;&gt;#define CHECKEQUALRET(ret, compare)\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;if(ret == compare)\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;{\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;    std::cerr &amp;lt;&amp;lt; &amp;#34;error ocurred in &amp;#34; &amp;lt;&amp;lt; __FILE__\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;              &amp;lt;&amp;lt; &amp;#34;`s line &amp;#34; &amp;lt;&amp;lt; __LINE__\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;              &amp;lt;&amp;lt; &amp;#34;, error &amp;#34; &amp;lt;&amp;lt; ret;\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;    goto END;\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;}
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#1e889b&#34;&gt;#define CHECKNEQUALRET(ret, compare)\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;if(ret != compare)\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;{\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;    std::cerr &amp;lt;&amp;lt; &amp;#34;error ocurred in &amp;#34; &amp;lt;&amp;lt; __FILE__\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;              &amp;lt;&amp;lt; &amp;#34;`s line &amp;#34; &amp;lt;&amp;lt; __LINE__\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;              &amp;lt;&amp;lt; &amp;#34;, error &amp;#34; &amp;lt;&amp;lt; ret;\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;    goto END;\
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;}
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; WIDTH = &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; HEIGHT = &lt;span style=&#34;color:#b452cd&#34;&gt;50&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;* out_buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;* tmp_buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;* print_buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
std::atomic&amp;lt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt;&amp;gt; atomiclock;
std::atomic&amp;lt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt;&amp;gt; gotframe = &lt;span style=&#34;color:#658b00&#34;&gt;false&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#008b45&#34;&gt;lock&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* data, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;** p_pixels)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (atomiclock)
    {
        std::this_thread::sleep_for(std::chrono::microseconds(&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;));
    }
    atomiclock = &lt;span style=&#34;color:#658b00&#34;&gt;true&lt;/span&gt;;
    *p_pixels = out_buffer;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;unlock&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* data, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* id, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;* p_pixels)
{
    atomiclock = &lt;span style=&#34;color:#658b00&#34;&gt;false&lt;/span&gt;;
    gotframe = &lt;span style=&#34;color:#658b00&#34;&gt;true&lt;/span&gt;;
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;display&lt;/span&gt;(&lt;span style=&#34;color:#228b22&#34;&gt;/*void* data, void* id*/&lt;/span&gt;)
{
    atomiclock = &lt;span style=&#34;color:#658b00&#34;&gt;true&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!gotframe)
    {
        atomiclock = &lt;span style=&#34;color:#658b00&#34;&gt;false&lt;/span&gt;;
        std::this_thread::sleep_for(std::chrono::microseconds(&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;));
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
    }
    memcpy(tmp_buffer, out_buffer, HEIGHT * WIDTH * &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;);
    gotframe = &lt;span style=&#34;color:#658b00&#34;&gt;false&lt;/span&gt;;
    atomiclock = &lt;span style=&#34;color:#658b00&#34;&gt;false&lt;/span&gt;;

    HANDLE hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD pos = { &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; };
    SetConsoleCursorPosition(hConsoleOutput, pos);

    RGBQUAD* rgba = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;RGBQUAD*&amp;gt;(tmp_buffer);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; HEIGHT; ++i)
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; j &amp;lt; WIDTH; ++j)
        {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; point = rgba[WIDTH * i + j];
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; light = (point.rgbRed + point.rgbGreen + point.rgbBlue) / &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;;
            print_buffer[i * (WIDTH + &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) + j] = light &amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;127&lt;/span&gt; ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
        }
        print_buffer[i * (WIDTH + &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) + WIDTH] = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;\r&amp;#39;&lt;/span&gt;;
        print_buffer[i * (WIDTH + &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) + WIDTH + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;] = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
    }
    puts(print_buffer);
}

&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;** argv)
{
    libvlc_instance_t* inst_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    libvlc_media_t* media_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    libvlc_media_player_t* player_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    libvlc_media_list_t* list_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    libvlc_media_list_player_t* plist_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ret = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;

    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Usage: Character-player [media file] [out width] [out height]&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (argc &amp;gt;= &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;)
    {
        WIDTH = atoi(argv[&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;]);
        HEIGHT = atoi(argv[&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;]);
    }

    HANDLE hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD size = { WIDTH + &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;, HEIGHT + &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt; };
    SetConsoleScreenBufferSize(hConsoleOutput, size);
    SMALL_RECT rc = { &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, WIDTH + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, HEIGHT + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; };
    SetConsoleWindowInfo(hConsoleOutput, &lt;span style=&#34;color:#658b00&#34;&gt;true&lt;/span&gt;, &amp;amp;rc);

    libvlc_log_close(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);

    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt; exit = &lt;span style=&#34;color:#658b00&#34;&gt;false&lt;/span&gt;;
    std::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;thread&lt;/span&gt; th([&amp;amp;]()
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!exit)
        {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (atomiclock)
            {
                std::this_thread::sleep_for(std::chrono::microseconds(&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;));
            }
            display();
        }
    });

    inst_ = libvlc_new(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);
    CHECKEQUALRET(inst_, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);
    media_ = libvlc_media_new_path(inst_, argc &amp;lt;= &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;badapple.mp4&amp;#34;&lt;/span&gt; : argv[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;]);
    CHECKEQUALRET(media_, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);

    out_buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;*&amp;gt;(malloc(HEIGHT * WIDTH * &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;));
    CHECKEQUALRET(out_buffer, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);
    tmp_buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;*&amp;gt;(malloc(HEIGHT * WIDTH * &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;));
    CHECKEQUALRET(tmp_buffer, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);
    print_buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;*&amp;gt;(malloc(HEIGHT * (WIDTH + &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;));
    CHECKEQUALRET(print_buffer, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);
    print_buffer[HEIGHT * (WIDTH + &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;)] = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;

    &lt;span style=&#34;color:#228b22&#34;&gt;//player_ = libvlc_media_player_new_from_media(media_);
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    player_ = libvlc_media_player_new(inst_);
    CHECKEQUALRET(player_, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;);

    libvlc_video_set_callbacks(player_, lock, unlock, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    libvlc_video_set_format(player_, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;RGBA&amp;#34;&lt;/span&gt;, WIDTH, HEIGHT, WIDTH * &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;);
    &lt;span style=&#34;color:#228b22&#34;&gt;//libvlc_media_player_set_hwnd(player_, GetDesktopWindow());
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    
    &lt;span style=&#34;color:#228b22&#34;&gt;// play loop
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    list_ = libvlc_media_list_new(inst_);
    plist_ = libvlc_media_list_player_new(inst_);
    libvlc_media_list_add_media(list_, media_);
    libvlc_media_list_player_set_media_list(plist_, list_);
    libvlc_media_list_player_set_media_player(plist_, player_);
    libvlc_media_list_player_set_playback_mode(plist_, libvlc_playback_mode_loop);
    libvlc_media_list_player_play(plist_);

    std::cin.get();

END:
    exit = &lt;span style=&#34;color:#658b00&#34;&gt;true&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (th.joinable())
    {
        th.join();
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (player_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_media_player_stop(player_);
        libvlc_media_player_release(player_);
        player_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (media_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_media_release(media_);
        media_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (plist_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_media_list_player_release(plist_);
        plist_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (list_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_media_list_release(list_);
        list_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (inst_ != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        libvlc_release(inst_);
        inst_ = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (print_buffer != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        free(print_buffer);
        print_buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (out_buffer != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        free(out_buffer);
        out_buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (tmp_buffer != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;)
    {
        free(tmp_buffer);
        tmp_buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://gongluck.github.io/cpp/badapple-console/ - </description>
        </item>
    
    
    
        <item>
        <title>第一篇博客</title>
        <link>https://gongluck.github.io/default/first/</link>
        <pubDate>Mon, 06 Apr 2020 19:43:00 +0800</pubDate>
        
        <guid>https://gongluck.github.io/default/first/</guid>
        <description>gongluck&#39;s blog https://gongluck.github.io/default/first/ -&lt;h3 id=&#34;第一篇博客&#34;&gt;第一篇博客&lt;/h3&gt;
&lt;p&gt;本博客网站使用Hugo创建,参考了&lt;a href=&#34;https://www.bilibili.com/video/av51574688&#34;&gt;视频&lt;/a&gt;,十分便捷。&lt;/p&gt;
- https://gongluck.github.io/default/first/ - </description>
        </item>
    
    
  </channel>
</rss> 